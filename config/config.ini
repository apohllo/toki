; Configuration for tokenising Polish.
; The language-dependent rules are within layer:ab_classify (regexes for
; inflectional endings of abbreviations and other abbrev heuristics) and
; layer:ab_lexicon (ref to a file with Polish abbrevs)

[input]
	token_type=t
	srx=segment.srx
	srx_language=PL_two
	initial_whitespace=newline

[layer:exc_0]
; always split on symbols (S) and punctuation (P)
; EXCEPT for two hyphens and :;.,@$+~=/?&%#~_
; these exceptions are for URLs, e-mails, numbers and hyphenated inflected abbrevs
; NOTE: hyphens not included
	class=split
	separators=[[\p{S} \p{P}]-[\u002d \u2010 : ; \. , @ \$ \+ ~ \= / \? \& % # ~ _]]
	separator_token_type=p

[layer:suff_safe]
; opening and closing punctuation, comma, colon, semicolon, quotation and exclamation mark
; detach these as suffixes
	class=affix_split
	process_types=t
	prefix_chars=[\p{Ps}]
	suffix_chars=[\p{Pe} , : ; \? !]
	suffix_token_type=p
	prefix_token_type=p

[layer:a_classify]
; abbrev regex classification
	class=regexp
	process_types=t
	; consonant-only abbrevs (at least two letter long)
	type:a=[BCĆDFGHJKLŁMNŃPRSŚTVWXYZŹŻbcćdfghjklłmnńprsśtvwxyzźż][bcćdfghjklłmnńprsśtvwxyzźż]+\.
	; multipart abbrevs (m.in., op.cit.)
	type:a=\p{Ll}{1,6}\.(\p{Lowercase}{1,6}\.)+

[layer:a_lexicon]
; recognise abbrevs listed in the lexicon
	class=lexicon_caseless
	process_types=t
	token_type=a
	lexicon_file=abbrevs.txt

[layer:suff_dot]
; detach token-final dots as full stop or ellipsis (thus group split)
	process_types=t
	class=group_affix_split
	suffix_chars=.
	suffix_token_type=p
	prefix_token_type=p

[layer:tu_classify]
; recognise likely e-mails and URLs
	class=regexp
	process_types=t
	type:tm=[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}
	type:tu=(([a-zA-Z]+)://)?((([a-zA-Z0-9-]+)(\.([a-zA-Z0-9-]+))*\.[a-zA-Z]{2,6})|((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))(:[0-9]{1,5})?(/[a-zA-Z0-9.,;\?|\'+&%\$#=~_-]+)*[/]?

[layer:exc_1]
; always split on symbols (S) and punctuation (P)
; EXCEPT for two hyphens and :.,
; these exceptions are left for numbers and inflected abbrevs
	class=split
	process_types=t
	separators=[[\p{S} \p{P}]-[\u002d \u2010 \: \. ,]]
	separator_token_type=p

[layer:n_classify]
; recognise numbers, date, time and IP numbers
	class=regexp
	process_types=t
	type:n=[0-9]+
	type:n_f=[0-9]+,[0-9]+
	type:n_d=(((0[1-9]|[12][0-9]|3[01])[-/.](0[1-9]|1[012])[-/.]((1|2)\d)?\d\d)|((((1|2)\d)?\d\d\d\d)[-/.](0[1-9]|1[012])[-/.](0[1-9]|[12][0-9]|3[01])))
	type:n_t=(24(:|[.])00|([01]?[0-9]|2[0-3])(:|[.])[0-5][0-9])((:|[.])[0-5][0-9])?
	type:n_ip=([0-9]{1,3})(\.[0-9]{1,3}){3}

[layer:exc_2]
; now always split on :.,
; remaining exceptions: two hyphens
; these exceptions are left for inflected abbrevs
	class=split
	process_types=t
	separators=:.,
	separator_token_type=p

[layer:th_classify]
; PRL-u etc. -> th
; other regex classification
	class=regexp
	process_types=t
	; upper-case + inflectional suffix
	type:th=\p{Lu}+[\u002d\u2010](?i:u|owi|em|ie|a|y|e|ach|om|ów|ami)
	; lower case ended in one of the letters that end in a consonant when pronounced + infl suff
	type:th=\p{Ll}{0,5}[fjlłmnńrsśvxz][\u002d\u2010](?i:u|owi|em|ie|a|y|e|ach|om|ów|ami)

[layer:hyphen]
; now get the remaining hyphens (hyphen-minus, hyphen proper) as groups
	class=group_split
	process_types=t
	separators=\u002d\u2010
	separator_token_type=p

[layers]
	layer=exc_0
	layer=suff_safe
	layer=a_lexicon
	layer=a_classify
	layer=suff_dot
	layer=tu_classify
	layer=exc_1
	layer=n_classify
	layer=exc_2
	layer=th_classify
	layer=hyphen

[debug]
	format=$orth/$type:$ws\n
